/**
 * Property-Based Tests for Blog Filtering Utilities
 * 
 * Feature: admin-dashboard
 * Properties: 4, 5
 * Validates: Requirements 3.1, 3.5, 3.6
 */

import fc from 'fast-check';
import {
  validateArticleDisplayFields,
  validateArticleListCompleteness,
  filterByStatus,
  filterByCategory,
  filterBySearch,
  filterArticles,
  articleMatchesCriteria,
  verifyFilterResults,
  ARTICLE_CATEGORIES,
  type AdminArticleListItem,
  type ArticleFilterCriteria,
} from './blog-utils';
import type { ArticleCategory } from '@/lib/blog/types';

// ============================================================================
// Arbitrary Generators
// ============================================================================

/**
 * Generate a valid article category
 */
function articleCategory(): fc.Arbitrary<ArticleCategory> {
  return fc.constantFrom(...ARTICLE_CATEGORIES);
}

/**
 * Generate a valid ISO date string
 */
function isoDateString(): fc.Arbitrary<string> {
  const minTime = new Date('2024-01-01T00:00:00Z').getTime();
  const maxTime = new Date('2026-12-31T23:59:59Z').getTime();
  return fc.integer({ min: minTime, max: maxTime })
    .map(timestamp => new Date(timestamp).toISOString());
}

/**
 * Generate a valid admin article list item
 */
function adminArticleListItem(): fc.Arbitrary<AdminArticleListItem> {
  return fc.record({
    id: fc.uuid(),
    slug: fc.string({ minLength: 3, maxLength: 100 })
      .filter(s => /^[a-z0-9-]+$/.test(s))
      .map(s => s.toLowerCase().replace(/[^a-z0-9-]/g, '-')),
    title: fc.string({ minLength: 1, maxLength: 200 })
      .filter(s => s.trim().length > 0), // Ensure title is not just whitespace
    summary: fc.string({ minLength: 1, maxLength: 500 })
      .filter(s => s.trim().length > 0), // Ensure summary is not just whitespace
    category: articleCategory(),
    tags: fc.array(fc.string({ minLength: 1, maxLength: 30 }), { minLength: 0, maxLength: 5 }),
    thumbnailUrl: fc.option(fc.webUrl(), { nil: null }),
    readingTime: fc.integer({ min: 1, max: 60 }),
    isPublished: fc.boolean(),
    createdAt: isoDateString(),
    updatedAt: isoDateString(),
  });
}

/**
 * Generate a valid slug string
 */
function slugString(): fc.Arbitrary<string> {
  return fc.stringMatching(/^[a-z][a-z0-9-]{2,49}$/);
}

/**
 * Generate filter criteria
 */
function filterCriteria(): fc.Arbitrary<ArticleFilterCriteria> {
  return fc.record({
    status: fc.option(fc.constantFrom('all', 'published', 'draft') as fc.Arbitrary<'all' | 'published' | 'draft'>, { nil: undefined }),
    category: fc.option(
      fc.oneof(
        fc.constant('all' as const),
        articleCategory()
      ),
      { nil: undefined }
    ),
    search: fc.option(fc.string({ minLength: 0, maxLength: 50 }), { nil: undefined }),
  });
}

/**
 * Generate a non-empty search string that exists in at least one article
 */
function searchStringFromArticles(articles: AdminArticleListItem[]): fc.Arbitrary<string> {
  if (articles.length === 0) {
    return fc.constant('');
  }
  
  // Pick a random article and extract a substring from title or summary
  return fc.integer({ min: 0, max: articles.length - 1 }).chain(index => {
    const article = articles[index];
    const source = article.title.length > article.summary.length ? article.title : article.summary;
    if (source.length < 3) {
      return fc.constant(source);
    }
    return fc.integer({ min: 0, max: Math.max(0, source.length - 3) }).map(start => {
      const len = Math.min(10, source.length - start);
      return source.substring(start, start + len);
    });
  });
}

// ============================================================================
// Property 4: Article List Display Completeness
// ============================================================================

describe('Property 4: Article List Display Completeness', () => {
  /**
   * Property 4a: Valid articles have all required fields
   * 
   * For any valid article generated by our arbitrary, all required fields
   * should be present and valid.
   */
  it('Property 4a: Valid articles have all required fields', () => {
    fc.assert(
      fc.property(
        adminArticleListItem(),
        (article) => {
          const validation = validateArticleDisplayFields(article);

          // All required fields should be present
          expect(validation.isComplete).toBe(true);
          expect(validation.missingFields).toHaveLength(0);

          // All values should be valid
          expect(validation.hasValidValues).toBe(true);
          expect(validation.invalidFields).toHaveLength(0);

          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * Property 4b: Article list validation detects all complete articles
   * 
   * For any array of valid articles, the list validation should report
   * all articles as complete.
   */
  it('Property 4b: Article list validation detects all complete articles', () => {
    fc.assert(
      fc.property(
        fc.array(adminArticleListItem(), { minLength: 0, maxLength: 50 }),
        (articles) => {
          const validation = validateArticleListCompleteness(articles);

          // All articles should be complete
          expect(validation.allComplete).toBe(true);
          expect(validation.incompleteArticles).toHaveLength(0);

          // All articles should be valid
          expect(validation.allValid).toBe(true);
          expect(validation.invalidArticles).toHaveLength(0);

          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * Property 4c: Missing title is detected
   * 
   * For any article with an empty title, validation should detect it.
   */
  it('Property 4c: Missing or empty title is detected', () => {
    fc.assert(
      fc.property(
        adminArticleListItem(),
        fc.constantFrom('', '   ', null as unknown as string),
        (article, badTitle) => {
          const invalidArticle = { ...article, title: badTitle };
          const validation = validateArticleDisplayFields(invalidArticle as AdminArticleListItem);

          // Should detect missing or invalid title
          const hasTitleIssue = 
            validation.missingFields.includes('title') ||
            validation.invalidFields.some(f => f.includes('title'));
          
          expect(hasTitleIssue).toBe(true);

          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * Property 4d: Invalid category is detected
   * 
   * For any article with an invalid category, validation should detect it.
   */
  it('Property 4d: Invalid category is detected', () => {
    fc.assert(
      fc.property(
        adminArticleListItem(),
        fc.string({ minLength: 1, maxLength: 20 }).filter(s => 
          !ARTICLE_CATEGORIES.includes(s as ArticleCategory)
        ),
        (article, badCategory) => {
          const invalidArticle = { ...article, category: badCategory as ArticleCategory };
          const validation = validateArticleDisplayFields(invalidArticle);

          // Should detect invalid category
          const hasCategoryIssue = validation.invalidFields.some(f => f.includes('category'));
          expect(hasCategoryIssue).toBe(true);

          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * Property 4e: Invalid date is detected
   * 
   * For any article with an invalid date, validation should detect it.
   */
  it('Property 4e: Invalid date is detected', () => {
    fc.assert(
      fc.property(
        adminArticleListItem(),
        fc.constantFrom('invalid-date', 'not-a-date', '2024-13-45'),
        (article, badDate) => {
          const invalidArticle = { ...article, createdAt: badDate };
          const validation = validateArticleDisplayFields(invalidArticle);

          // Should detect invalid date
          const hasDateIssue = validation.invalidFields.some(f => f.includes('createdAt'));
          expect(hasDateIssue).toBe(true);

          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * Property 4f: Each article in list is validated independently
   * 
   * For any list with one invalid article, only that article should be flagged.
   */
  it('Property 4f: Each article in list is validated independently', () => {
    fc.assert(
      fc.property(
        fc.array(adminArticleListItem(), { minLength: 2, maxLength: 20 }),
        fc.integer({ min: 0, max: 19 }),
        (articles, invalidIndex) => {
          // Ensure index is within bounds
          const idx = invalidIndex % articles.length;
          
          // Make one article invalid
          const modifiedArticles = articles.map((a, i) => 
            i === idx ? { ...a, title: '' } : a
          );

          const validation = validateArticleListCompleteness(modifiedArticles);

          // Should have exactly one incomplete article
          expect(validation.allComplete).toBe(false);
          expect(validation.incompleteArticles.length + validation.invalidArticles.length).toBeGreaterThanOrEqual(1);

          return true;
        }
      ),
      { numRuns: 100 }
    );
  });
});

// ============================================================================
// Property 5: Article Filtering Correctness
// ============================================================================

describe('Property 5: Article Filtering Correctness', () => {
  /**
   * Property 5a: Status filter returns only matching articles
   * 
   * For any set of articles and status filter, all returned articles
   * should have the matching status.
   */
  it('Property 5a: Status filter returns only matching articles', () => {
    fc.assert(
      fc.property(
        fc.array(adminArticleListItem(), { minLength: 0, maxLength: 50 }),
        fc.constantFrom('all', 'published', 'draft') as fc.Arbitrary<'all' | 'published' | 'draft'>,
        (articles, status) => {
          const filtered = filterByStatus(articles, status);

          if (status === 'all') {
            // All articles should be returned
            expect(filtered.length).toBe(articles.length);
          } else if (status === 'published') {
            // All returned articles should be published
            for (const article of filtered) {
              expect(article.isPublished).toBe(true);
            }
          } else if (status === 'draft') {
            // All returned articles should be drafts
            for (const article of filtered) {
              expect(article.isPublished).toBe(false);
            }
          }

          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * Property 5b: Category filter returns only matching articles
   * 
   * For any set of articles and category filter, all returned articles
   * should have the matching category.
   */
  it('Property 5b: Category filter returns only matching articles', () => {
    fc.assert(
      fc.property(
        fc.array(adminArticleListItem(), { minLength: 0, maxLength: 50 }),
        fc.oneof(fc.constant('all' as const), articleCategory()),
        (articles, category) => {
          const filtered = filterByCategory(articles, category);

          if (category === 'all') {
            // All articles should be returned
            expect(filtered.length).toBe(articles.length);
          } else {
            // All returned articles should have the specified category
            for (const article of filtered) {
              expect(article.category).toBe(category);
            }
          }

          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * Property 5c: Search filter returns only matching articles
   * 
   * For any set of articles and search query, all returned articles
   * should contain the search query in title or summary.
   */
  it('Property 5c: Search filter returns only matching articles', () => {
    fc.assert(
      fc.property(
        fc.array(adminArticleListItem(), { minLength: 0, maxLength: 50 }),
        fc.string({ minLength: 0, maxLength: 30 }),
        (articles, search) => {
          const filtered = filterBySearch(articles, search);
          const searchLower = search.trim().toLowerCase();

          if (!searchLower) {
            // Empty search should return all articles
            expect(filtered.length).toBe(articles.length);
          } else {
            // All returned articles should contain the search query
            for (const article of filtered) {
              const titleMatch = article.title.toLowerCase().includes(searchLower);
              const summaryMatch = article.summary.toLowerCase().includes(searchLower);
              expect(titleMatch || summaryMatch).toBe(true);
            }
          }

          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * Property 5d: Combined filters return only articles matching ALL criteria
   * 
   * For any set of articles and filter criteria, all returned articles
   * should match ALL specified criteria.
   */
  it('Property 5d: Combined filters return only articles matching ALL criteria', () => {
    fc.assert(
      fc.property(
        fc.array(adminArticleListItem(), { minLength: 0, maxLength: 50 }),
        filterCriteria(),
        (articles, criteria) => {
          const filtered = filterArticles(articles, criteria);

          // Verify all filtered articles match all criteria
          const verification = verifyFilterResults(filtered, criteria);
          expect(verification.allMatch).toBe(true);
          expect(verification.nonMatchingArticles).toHaveLength(0);

          // Also verify using articleMatchesCriteria
          for (const article of filtered) {
            expect(articleMatchesCriteria(article, criteria)).toBe(true);
          }

          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * Property 5e: Filtering is idempotent
   * 
   * For any set of articles and filter criteria, filtering twice
   * should produce the same result as filtering once.
   */
  it('Property 5e: Filtering is idempotent', () => {
    fc.assert(
      fc.property(
        fc.array(adminArticleListItem(), { minLength: 0, maxLength: 50 }),
        filterCriteria(),
        (articles, criteria) => {
          const filteredOnce = filterArticles(articles, criteria);
          const filteredTwice = filterArticles(filteredOnce, criteria);

          // Should have same length
          expect(filteredTwice.length).toBe(filteredOnce.length);

          // Should have same articles (by id)
          const idsOnce = new Set(filteredOnce.map(a => a.id));
          const idsTwice = new Set(filteredTwice.map(a => a.id));
          expect(idsTwice).toEqual(idsOnce);

          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * Property 5f: Filtered results are subset of original
   * 
   * For any set of articles and filter criteria, the filtered results
   * should be a subset of the original articles.
   */
  it('Property 5f: Filtered results are subset of original', () => {
    fc.assert(
      fc.property(
        fc.array(adminArticleListItem(), { minLength: 0, maxLength: 50 }),
        filterCriteria(),
        (articles, criteria) => {
          const filtered = filterArticles(articles, criteria);

          // Filtered count should be <= original count
          expect(filtered.length).toBeLessThanOrEqual(articles.length);

          // All filtered articles should exist in original
          const originalIds = new Set(articles.map(a => a.id));
          for (const article of filtered) {
            expect(originalIds.has(article.id)).toBe(true);
          }

          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * Property 5g: No matching articles are excluded
   * 
   * For any set of articles and filter criteria, no article that matches
   * all criteria should be excluded from the results.
   */
  it('Property 5g: No matching articles are excluded', () => {
    fc.assert(
      fc.property(
        fc.array(adminArticleListItem(), { minLength: 0, maxLength: 50 }),
        filterCriteria(),
        (articles, criteria) => {
          const filtered = filterArticles(articles, criteria);
          const filteredIds = new Set(filtered.map(a => a.id));

          // Check that all matching articles are included
          for (const article of articles) {
            if (articleMatchesCriteria(article, criteria)) {
              expect(filteredIds.has(article.id)).toBe(true);
            }
          }

          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * Property 5h: Empty criteria returns all articles
   * 
   * For any set of articles, empty filter criteria should return all articles.
   */
  it('Property 5h: Empty criteria returns all articles', () => {
    fc.assert(
      fc.property(
        fc.array(adminArticleListItem(), { minLength: 0, maxLength: 50 }),
        (articles) => {
          const emptyCriteria: ArticleFilterCriteria = {};
          const filtered = filterArticles(articles, emptyCriteria);

          // Should return all articles
          expect(filtered.length).toBe(articles.length);

          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * Property 5i: Filter order doesn't matter
   * 
   * For any set of articles and filter criteria, applying filters in
   * different orders should produce the same result.
   */
  it('Property 5i: Filter order does not affect results', () => {
    fc.assert(
      fc.property(
        fc.array(adminArticleListItem(), { minLength: 0, maxLength: 50 }),
        fc.constantFrom('published', 'draft') as fc.Arbitrary<'published' | 'draft'>,
        articleCategory(),
        fc.string({ minLength: 1, maxLength: 20 }),
        (articles, status, category, search) => {
          // Order 1: status -> category -> search
          const order1 = filterBySearch(
            filterByCategory(
              filterByStatus(articles, status),
              category
            ),
            search
          );

          // Order 2: search -> status -> category
          const order2 = filterByCategory(
            filterByStatus(
              filterBySearch(articles, search),
              status
            ),
            category
          );

          // Order 3: category -> search -> status
          const order3 = filterByStatus(
            filterBySearch(
              filterByCategory(articles, category),
              search
            ),
            status
          );

          // All orders should produce same result
          const ids1 = new Set(order1.map(a => a.id));
          const ids2 = new Set(order2.map(a => a.id));
          const ids3 = new Set(order3.map(a => a.id));

          expect(ids1).toEqual(ids2);
          expect(ids2).toEqual(ids3);

          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * Property 5j: Search is case-insensitive
   * 
   * For any article and search query, the search should be case-insensitive.
   */
  it('Property 5j: Search is case-insensitive', () => {
    fc.assert(
      fc.property(
        fc.array(adminArticleListItem(), { minLength: 1, maxLength: 20 }),
        (articles) => {
          // Get a word from the first article's title
          const firstTitle = articles[0].title;
          if (firstTitle.length < 2) return true;

          const searchWord = firstTitle.substring(0, Math.min(5, firstTitle.length));
          
          // Search with different cases
          const lowerResult = filterBySearch(articles, searchWord.toLowerCase());
          const upperResult = filterBySearch(articles, searchWord.toUpperCase());
          const mixedResult = filterBySearch(articles, searchWord);

          // All should return same results
          const lowerIds = new Set(lowerResult.map(a => a.id));
          const upperIds = new Set(upperResult.map(a => a.id));
          const mixedIds = new Set(mixedResult.map(a => a.id));

          expect(lowerIds).toEqual(upperIds);
          expect(upperIds).toEqual(mixedIds);

          return true;
        }
      ),
      { numRuns: 100 }
    );
  });
});
